## 스케줄링의 개요

#### 스케줄링의 단계
CPU스케줄러는 관리의 범주를 나누어 스케줄링한다
- 고수준스케줄링 : 시스템내의 전체 작업수를 조절하는 것으로 어떤 작업을 시스템에 받아들일지 또는 거부할지 결정하는 단계
- 중간수준스케줄링 : 시스템 부하를 조절하기 위해 이미 활성화된 프로세스중 일부를 보류상태로 보내고 이후 이유가 생기면 다시 활성화 해주는 단계
- 저수준스케줄링 : 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기상태로 보낼지 결정하는 단계
<img src="https://github.com/YboSim/Study/blob/main/Data/4-1.CPUscheduling.png" width="600" height="600" />

#### 스케줄링의 목적
- 공평성 : 모든 프로세스가 자원을 공평하게 배정하도록 함
- 효율성 : 시스템 자원이 유휴 시간 없이 사용되도록 함
- 안정성 : 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원을 보호하도록 함
- 확장성 : 프로세스가 증가해도 시스템이 안정적으로 작동하도록 함
- 반응시간보장 : 사용자가 시스템이 멈춘것으로 오인한는것을 방지하기위해 적절한 시간내에 프로세스의 요구에 반응하도록 함
- 무한연기방지 : 프로세스의 작업이 무한히 연기되는것을 막음

## 스케줄링 시 고려사항

#### 선점형 / 비선점형 스케줄링
- 선점형 스케줄링 : 어떤 프로세스가 CPU를 할당받아 실행중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식
- 비선점형 스케줄링 : 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식

|구분|선점형 스케줄링|비선점형 스케줄링|
|:---|:---|:---|
|작업 방식|실행 상태에 있는 작업을 중단시키고 새로운 작업을 실행할 수 있다|실행 상태에 있는 작업이 완료될 때까지 다른 작업이 불가능하다|
|장점|프로세스가 CPU를 독점할 수 없다|CPU 스케줄러의 작업량이 적고 문맥 교환의 오버헤드가 적다|
|단점|문맥교환의 오버헤드가 많다|기다리는 프로세스가 많아 처리율이 떨어진다|
|사용|시분할 방식 스케줄링|일괄 작업 방식 스케줄링|
|중요도|높다|낮다|

#### 프로세스 우선순위
- 프로세스의 우선순위가 없다는 것은 모든프로세스의 중요도가 같다는 것을 의미하는대, 이는 스케줄링의 목적에 공평성과 반응시간보장에 맞지 않다
- 프로세스는 커널 프로세스와 일반프로세스로 나뉘는대 커널프로세스가 일반프로세스보다 우선순위가 높다
- 각 커널프로세스간 우선순위가 존재하고 일반프로세스 역시 각 프로세스간 우선순위가 존재한다
- 우선순위가 높다는 것은 더 빨리 자주 실행된다는것을 의미한다
- 일반프로세스를 사용자가 조절 할 수 있지만 해당프로세스 뿐만 아니라 다른 프로세스의 실행속도에도 영향을 미칠 수 있다는것에 주의해야 한다

#### CPU집중 / 입출력집중 프로세스
- CPU집중 프로세스는 수학연산과 같이 CPU를 많이 사용하는 프로세스이고 입출력집중 프로세스는 저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스이다
- CPU집중 프로세스와 입출력집중 프로세스가 같이 있을 때는 CPU집중 프로세스를 먼저 실행상태로 옮기면 다른 프로세스들이 CPU를 사용 할 수 없기 때문에 입출력집중 프로세스를 먼저 실행상태로 옮기고 입출력 요구에 의해 대기상태로 옮겨지면 다른 프로세스들이 CPU를 사용할 수 있게 된다
  (즉, 입출력집중 프로세스가 CPU집중 프로세스보다 우선순위가 높아야 효율성이 높다)
- 하기의 비교결과를 보면 이해가 쉽다
![비교결과](/Data/4-2.Compare.png)

#### 전면 / 후면 프로세스
- 전면 프로세스는 GUI를 사용하는 운영체제에서 화면에 맨앞에 놓인 프로세스로서, 예를 들어 컴퓨터 모니터의 웹브라우저와 워드가 있고 웹브라우저가 워드보다 앞에 나와있으면 웹브라우저가 전면프로세스가 되고 워드가 후면프로세스가 된다
- 전면 프로세스와 후면 프로세스가 같이 있을 때 전면 프로세스는 사용자의 요구에 즉각 반응해야 하기 때문에 후면 프로세스보다 우선순위가 높다

#### 프로세스 우선순위 비교

|우선순위 높음|우선순위 낮음|
|:---:|:---:|
|커널 프로세스|일반 프로세스|
|전면 프로세스|후면 프로세스|
|대화형 프로세스|일괄 처리 프로세스|
|입출력집중 프로세스|CPU집중 프로세스|

## 다중 큐

#### 다중큐의 목적
- 프로세스의 중요도는 저마다 다르며 중요도는 PCB에 표시된다
- 매번 모든 PCB을 검색하려면 매우 번거롭기 때문에 우선순위에 따라 단일 혹은 여러개의 큐를 만들어 관리한다

#### 준비상태의 큐
![준비상태큐](/Data/4-3.Queue.png)
- 프로세스의 준비상태에 들어올때 마다 자신의 우선순위에 해당하는 큐의 마지막(tail)에 삽입된다
- 여러개의 준비큐에 있는 프로세스 중 어떤 프로세스에 CPU를 할당할지 결정하는 것은 스케줄링 알고리즘에 따라 결정된다
- 프로세스의 우선순위 배정방식에는 **고정 우선순위 방식**과 **변동 우선순위 방식**이 있다
  1) 고정 우선순위 방식 : 운영체제가 프로세스에 우선순위를 부여하면 프로세스가 끝날때까지 바뀌지 않는 방식
  2) 변동 우선순위 방식 : 프로세스 생성 시 부여받은 우선순위가 프로세스 작업 중간에 변하는 방식
- 프로세스 상태와 준비 큐
  1) 프로세스가 생성 상태에서 준비상태로 넘어오는 과정에서 PCB이 생성되면서 우선순위가 결정되고 해당 PCB이 큐에 삽입된다
  2) 사용하는 스케줄링 알고리즘에 따라 스케줄러가 우선순위가 높은 큐의 PCB을 가져와 CPU를 할당시킨다
  3) 실행상태에서 준비상태로 돌아오는 PCB역시 상기와 같은 방식으로 반복

#### 대기상태의 큐
- 대기상태에서는 같은 입출력을 요구한 프로세스끼리 큐로 모아놓는다
- 대기큐는 준비큐와 달리 여러개의 PCB을 동시에 꺼내 준비상태로 옮긴다
- 동시에 꺼내는 인터럽트를 처리하기 위해 **인터럽트 벡터**라는 자료구조를 사용한다
- 인터럽트 벡터에는 동시에 완료된 입출력 정보와 처리방법이 담겨 있는데, 이 정보에 따라 완료된 PCB은 모두 준비상태로 이동한다
- 프로세스 상태와 대기 큐
  1) 실행상태의 PCB이 입출력 요청에 의해 대기 큐로 삽입된다
  2) 이때 같은 입출력을 요구한 프로세스의 큐에 삽입된다
  3) 입출력이 완료되면 인터럽트가 발생되고 준비상태의 큐로 삽입

## 스케줄링 알고리즘
스케줄링 알고리즘은 크게 **비선점형 알고리즘**과 **선점형 알고리즘**으로 나뉜다.
- 비선점형 알고리즘 : 프로세스가 CPU를 할당받으면 작업이 끝날때까지 다른프로세스로 넘겨주지 않는 알고리즘
- 선점형 알고리즘 : 프로세스가 CPU를 할당받아 일정시간동안 작업을 한 후 완료하지않아도 다른프로세스로 CPU를 넘겨줄 수 있는 알고리즘

|구분|종류|
|:---|:---|
|비선점형 알고리즘|FCFS,SJF,HRN|
|선점형 알고리즘|RR,SRT,MLQ,MLFQ|
|둘다 가능|우선순위 스케줄링|

#### 스케줄링 알고리즘의 선택 기준
- CPU 사용률 : 전체 시스템의 동작 시간중 CPU가 사용된 기간을 측정하는 방법(높을수록 좋다)
- 처리량 : 단위시간당 작업을 마친 프로세스 수(높을수록 좋다)
- 대기시간 : 작업을 요청한 프로세스가 실제 작업을 시작하기 전까지 대기하는 시간(짧을수록 좋다)
- 응답시간 : 프로세스 시작 후 첫번째 출력 또는 반응이 나올 때까지 걸리는 시간(짧을 수록 좋다)
- 반환시간 : 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간(반환시간 = 대기시간 + 실행시간)
- CPU 사용률과 처리량은 계산하기가 어려워 주로 대기시간,응답시간,반환시간을 계산한다
- 스케줄링 알고리즘의 성능을 비교할 때는 주로 평균대기시간을 본다(평균대기시간 = 모든 프로세스의 대기시간 / 프로세스의 수)

#### 스케줄링 알고리즘의 비교

|구분|동작|방식&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|평가|
|:---|:---|:---|:---|
|FCFS(선입선출 스케줄링)|프로세스가 큐에 도착한 순서대로 실행되는 방식으로 모든 프로세스의 우선순위가 동일하다|비선점형|단순하고 공평하지만 처리시간이 긴프로세스가 CPU를 한번 차지하면 다른프로세스들은 CPU를 할당하지 못하기 때문에 효율성이 떨어지며 실행상태인 프로세스가 입출력 작업을 요청하는 경우에도 CPU가 쉬는시간이 많아져 효율성이 떨어진다|
|SJF(최단 작업 우선 스케줄링)|준비큐에 있는 프로세스중에서 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 방식|비선점형|운영체제가 프로세의 종료시간을 정확하게 예측하기 어렵고 작업시간이 긴 프로세스들이 계속 뒤로밀려 아사현상이 이러날 수 있기 때문에 사용하기 어렵다|
|HRN(최고 응답률 우선 스케줄링)|SJF스케줄링의 아사현상을 해결하기 위해 대기시간과 CPU사용시간을 고려하여 스케줄링 하는 방식으로 **우선순위 = (대기시간 + CPU사용시간) / CPU사용시간**이다|비선점형|SJF스케줄링의 아사현상을 완화시킬 수 있지만 여전히 공평성에 위배되어 많이 사용되지 않는다|
|RR(라운드 로빈 스케줄링)|CPU에 할당된 프로세스가 할당받은시간 동안 작업을 하다가 완료하지 못하면 준비큐(단일큐)의 맨뒤로 가서 자기 차례를 다시 기다리는 방식|선점형|우선순위가 적용되지 않은 가장 단순한 선점형 스케줄링 방식으로 문맥교환시간이 추가되어 평균대기시간을 산출하면 비효율적일 수도 있지만 공평성에 적합하다|
|SRT(최소 잔류 시간 우선 스케줄링)|SJF의 선점형 버전으로 기본적으로 라운드 로빈 스케줄링을 사용하지만 CPU를 할당받을 프로세스를 선택할 때 남은 작업 시간이 가장 적은 프로세스를 선택한다|선점형|현재 실행 중인 프로세스와 큐에 있는 프로세스의 남는 시간을 주기적으로 계산하고 남은 시간이 더 적은 프로세스와 문맥교환을 해야 하므로 SJF에 없는 작업이 추가되어 효율성이 떨어진다|
|MLQ(다단계 큐 스케줄링)|우선순위에 따라 준비 큐를 여러개 사용하여 우선순위가 더높은 큐에있는 모든 프로세스의 작업이 끝나야 다음 우선순위의 큐의 작업이 시작된다. 각 큐는 라운드로빈 방식으로 운영되며 우선순위는 고정형 우선순위 방식이다|선점형|우선순위가 높은 상위 큐의 프로세스의 작업이 끝나기전에 하위큐의 프로세스의 작업을 할 수 없다는 문제점이 있다|
|MLFQ(다단계 피드백 큐 스케줄링)|MLQ스케줄링 방식의 문제점을 해결하기 위해 CPU를 사용한 프로세스가 해당 큐로 돌아가지(RR방식) 않고 우선순위가 하나 낮은 큐의 끝으로 들어가는 방식(변동 우선순위 방식)이다.우선 순위가 높은 프로세스는 타임슬라이스를 낮게 설정하고 우선순위가 낮은 프로세스는 타임슬라이스를 크게 설정하여 어렵게 얻은 CPU를 좀더 오래 사용하도록 한다.|선점형|우선순위가 낮은 프로세스의 CPU사용 접근성 문제를 어느정도 완화한 상태로 오늘날 운영체제가 CPU스케줄링 할 때 일반적으로 사용하는 방식이다|
