## 요구 페이징

##### 요구 페이징 개요
- 메모리에는 꼭 필요한 프로세스만 유지하는것이 좋기 때문에 필요한 모듈만만 메모리에 올려 실행하고 나머지 모듈은 필요하다고 판단될 때 메모리로 불러온다
- 사용자가 요구할 때 해당 페이지를 메모리로 가져오는 것을 **요구 페이징**이라 한다
- 사용자가 특정 기능을 요구할 때 해당 모듈을 메모리에 올리면 메모리의 절약과 효율적 관리, 프로세스의 응답 속도 향상 등의 장점이 있다
- 요구 페이징과 반대로 앞으로 필요할 것이라고 예상되는 페이지를 미리 가져오는 방식을 **미리 가져오기**(ex. 캐시)라고 하는데, 미리 가져온 데이터가 쓸모없게 되면 피해가 클 수 있다

##### 페이지 테이블 엔트리(PTE)의 구조
- 페이지 테이블 엔트리는 크게 **페이지 번호, 플래그 비트, 주소 필드**로 구성되어 있다
- 페이지가 스왑영역에 있는경우는 요구 페이징으로 인해 처음부터 물리메모리에 올라가지 못한 경우와 메모리가 꽉 차서 스왑영역으로 옮겨 온 경우가 있는데, 페이지가 메모리에 있는지 스왑역영에 있는지 표시해주는 비트가 **유효 비트** 이다
- 플래그 비트 구성 요소
  1) 접근 비트(참조 비트) : 페이지가 메모리에 올라온 후 사용한 적이 있는지 알려준다(접근한적이 없으면 0, 있으면 1로 표시)
  2) 변경 비트(더티 비트) : 페이지가 메모리에 올라온 후 데이터 변경이 있었는지 알려준다(변경된적이 없으면0, 있으면 1로 표시)
  3) 유효 비트(현재 비트) : 페이지가 실제 메모리에 있는지 스왑 영역에 있는지 알려준다(물리메모리에 있으면0, 스왑영역에 있으면 1로 표시)
  4) 읽기, 쓰기, 실행 비트(접근 권환 비트) : 페이지에 대한 읽기, 쓰기, 실행 권환을 나타낸다

##### 페이지 부재
- 프로세스가 페이지를 요청했을 때 그 페이지가 메모리에 없는 상황을 **페이지 부재**라고 한다
- 유효 비트가 1일 때는 페이지가 스왑영역에 있으므로 주소 필드에 스왑 영역(저장장치) 내 페이지의 주소가 저장된다
- 페이지 부재 시 진행 과정
  1) 페이지 부재 발생
  2) 물리 메모리에 빈 공간이 있는지 확인 한다
  3) 없다면 교체 알고리즘을 통해 스왑 아웃을 할 페이지를 결정한 후 스왑아웃한다
  4) 스왑아웃된 PTE(플래그 비트/주소필드) 업데이트
  5) 대상 페이지 스왑인
  6) 스왑인된 PTE(플래그 비트/주소필드) 업데이트

## 페이지 교체 알고리즘

##### 페이지 교체 알고리즘 개요
- 페이지 부재가 발생 시 메모리가 꽉 찼다면 스왑아웃이 발생되어야 하는데, 이 때 **페이지 교체 알고리즘**을 통해 스왑아웃될 페이지를 결정한다
- 페이지 교체 알고리즘 분류

|종류|알고리즘|특징|
|:---|:---|:---|
|간단한 알고리즘|무작위|무작위로 대상 페이지를 선정하여 스왑 영역으로 보낸다|
|간단한 알고리즘|FIFO|처음 메모리 올라온 페이지를 스왑 영역으로 보낸다|
|이론적 알고리즘|최적|미래의 메모리 접근 패턴을 보고 대상 페이지를 선정하여 스왑영역으로 보낸다|
|최적 근접 알고리즘|LRU|시간적으로 멀리 떨어진 페이지를 스왑영역으로 보낸다|
|최적 근접 알고리즘|LFU|사용 빈도가 적은 페이지를 스왑영역으로 보낸다|
|최적 근접 알고리즘|NUR|최근에 사용한 적이 없는 페이지를 스왑 영역으로 보낸다|
|최적 근접 알고리즘|FIFO 변형|FIFO 알고리즘을 변형하여(단점을 보완하여) 성능을 높인다|
- 페이지 교체 알고리즘의 성능 평가 기준
  1) 페이지 부재 횟수를 확인한다
  2) 페이지를 요청한 후 실제로 작업에 들어갈 때까지의 평균 대기 시간을 측정한다
  3) 전체 작업에 걸리는 시간을 비교

##### 무작위 페이지 교체 알고리즘
- 대부분 프로세스의 메모리 접근 패턴으르 보면 가장 가까운 거리에 있는 페이지에 접근하는 지역성을 가지지만, 무작위 알고리즘은 이러한 지역정을 전혀 고려하지 않기 때문에 자주 사용하는 페이지가 대상 페이지로 선정되기도 한다
- 성능이 좋지 않아 거의 사용되지 않는다

##### FIFO 페이지 교체 알고리즘
- 시간상 메모리에 가장 먼저 들어온 페이지를 대상 페이지로 선정하여 스왑 영역으로 쫓아낸다
- 알고리즘 동작 순서
  1) 메모리에 페이지가 순차적으로 옮겨지다 꽉차게 된다
  2) 가장 오래된 페이지가 스왑영역으로 간다
  3) 기존에 있던 페이지들이 한칸식 위로 올라오고 대상 페이지가 가장 최근 자리에 위치한다
- 무조건 오래된 페이지를 대상 페이지로 선정하기 때문에 성능이 떨어져 잘 사용하지 않는다

##### 최적 페이지 교체 알고리즘
- 메모리가 앞으로 사용할 페이지를 미리 살펴보고 페이지 교체 선정 시점부터 사용 시점까지 가장 멀리 있는 페이지를 대상 페이지로 선정한다
- 알고리즘 동작 순서
  1) 메모리에 페이지가 순차적으로 옮겨지다 꽉차게 된다
  2) 미래 들어올 페이지 중 전체에서 가장 늦게 사용될 페이지를 스왕영역으로 쫓아낸다
- 최적 페이지 교체 알고리즘은 미래의 메모리 접근 패턴을 보고 대상 페이지를 결정하기 때문에 성능이 좋지만 미래의 접근 패턴을 알기는 불가능 하기 때문에 실제로 구현할 수 없다

##### LRU(Least Recently Used) 페이지 교체 알고리즘
- 메모리에 올라온 후 가장 오랫동안 사용되지 않는 페이지를 스왑영역으로 옮긴다
- 카운터를 이용하는 방법과 참조비트를 이용하는 방법으로 나뉜다
- 카운터에 기반한 구현 동작 순서
  1) 메모리에 페이지가 옮겨질 때마다 카운팅하고 카운팅한 숫자를 해당 시점에 올라온 페이지에 부여한다
  2) 가장 낮은 카운터를 가지는 페이지가 사용된지 가장 오래된 페이지이기 때문에 스왕영역으로 옮겨진다
- 참조 비트 시프트 방식 동작 순서
  1) 각 PTE의 참조 비트 초깃값을 0으로 설정
  2) 메모리에 페이지가 옮겨질 때마다 각 페이지들의 PTE 참조 비트를 오른 쪽으로 한칸씩 이동한 후 올라온 페이지의 PTE 참조 비트를 1로 바꾼다
  3) 참조비트를 갱신하다가 가장 작은 값의 페이지를 스왑영역으로 옮긴다(A - 01011010 / B - 10000000 / C - 00111101 이면 C가 옮겨진다)
- 카운트를 하든 참조 비트를 사용하던지간에 메모리 공간이 추가로 더들어간다는 단점이 있다

##### LFU(Least Frequently Used) 페이지 교체 알고리즘
- 페이지가 몇 번 사용 되었는지를 기준으로 대상 페이지를 선정하는 알고리즘
- 알고리즘 동작 순서
  1) 메모리에 페이지가 옮겨질 때마다 대상 페이지에 사용 빈도를 1씩 추가한다
  2) 메모리가 꽉 차 스왑아웃을 해야할 시점에 사용 빈도 숫자가 가장 적은 페이지를 스왑영역으로 옮긴다
- LRU와 마찬가지로 사용 빈도를 표시한는데 추가 공간이 필요하므로 메모리가 낭비된다

##### NUR(Not Used Recently) 페이지 교체 알고리즘
- LRU,LFU 페이지 교체 알고리즘과 성능이 비슷하지만 불필요한 공간 낭비 문제를 보완한 알고리즘 이다
- 참조 비트와 변경 비트 2bit만을 사용해 가장 적게 접근한 페이지를 스왑영역으로 옮긴다
- 스왑영역으로 옮겨질 대상 페이지 우선 순위
  
  |먼저 옮겨질 순위|(참조 비트 , 변경 비트)|비고|
  |:---:|:---:|:---:|
  |1|(0,0)|접근 한적도 변경이 일어난 적도 없음|
  |2|(0,1)|페이지에 쓰기 또는 추가 같은 변경이 일어남|
  |3|(1,0)|페이지에 읽기 또는 실행 같은 접근이 발생함|
  |4|(1,1)|접근과 변경 두가지 모두 발생|
- 초기 상태(0,0)에서 모든 페이지가 (1,1)이 되면 모든 페이지 비트를(0,0)으로 초기화 한다
- 2bit만 추가하여 다른 알고리즘과 유사한 성능을 낼 뿐만 아니라 쉽게 구현할 수 잇다는 장점 때문에 가장 많이 사용되는 알고리즘이다

##### FIFO 변형 알고리즘
- 2차 기회 페이지 교체 알고리즘 : FIFO 페이지 교체 알고리즘의 기본 구조에서 특정 페이지에 접근하여 페이지 부재 없이 성공할 경우 해당 페이지를 큐의 맨뒤로 이동하여 기회를 한번 더 주는 알고리즘
- 시계 알고리즘 동작 방식
  1) 각 페이지의 참조 비트 초기값을 0으로 설정한다
  2) 메모리에 있는 페이지를 성공적으로 참조하면 0에서 1로 변경된다
  3) 시계 알고리즘의 대상 포인터는 메모리가 꽉 찰 경우 스왑 영역으로 쫓겨날 페이지를 가리키는데, 가리키는 페이지가 스왑 영역으로 쫓겨나면 대상 포인터를 밑으로 이동시킨다
  4) 이 때 참조 비트가 1인 페이지는 건너뛰고(기회를 한번더 준다), 포인터는 메모리의 바닥에 도착하면 원형 큐 처럼 다시 메모리의 상단으로 이동한다
  5) 참조 비트가 1인 페이지를 건너 뛸때 다시 건너뛴 페이지는 참조비트를 다시 0으로 바꿔놓는다

## 스레싱과 프레임 할당

##### 스레싱
- 하드디스크의 입출력이 너무 많아져서 잦은 페이지 부재로 작업이 멈춘 것과 같은 상태를 **스레싱**이라고 한다
- 스레싱은 동시에 실행하는 프로그램의 수인 **멀티프로그래밍 정도**와 밀접한 관련이 있는데 멀티 프로그래밍 정도가 높아지면 스레싱이 발생한다
- 멀티프로그래밍 정도가 높아지면 CPU사용량이 증가하게되면서 메모리가 꽉차면 CPU가 작업하는 시간보다 스왑영역으로 페이지를 보내고 새로운 페이지를 메모리로 가져오는 작업이 빈번해져서 CPU가 작업할 수 없는 상태인 스레싱이 발생한다
- 실행 중인 여러 프로세스에 프레임을 얼마나 나누어 주느냐에 따라 시스템의 성능이 달라지기 때문에 남아 있는 프레임을 실행중인 프로세스에 적절히 나누어 주는 정책이 필요하다

##### 정적 할당
- 프로세스 실행 초기에 프레임을 나누어 준 후 크기를 고정하는 것으로, 균등 할당 방식과 비례 할당 방식이 있다
- 균등 할당 방식 : 프로세스의 크기와 상관없이 사용 가능한 프레임을 모든 프로세스에 동일하게 할당
- 비례 할당 방식 : 프로세스 크기에 비례하여 프레임을 할당하는 방식
- 정적 할당 방식은 프로세스가 실행 중에 필요로 하는 프레임을 유동적으로 반영하지 못하고 사용하지 않을 메모리를 처음부터 미리 확보하여 공간을 낭비한다는 단점이 있다

##### 동적 할당
- 프로세스는 실행 중에 어떨 때는 프레임이 많이 필요하고 적게 필요하기도 하는데, 이렇게 시시각각 변하는 요청을 수용하는 방식이다
- 작업 집합 모델을 사용하는 방식과 페이지 부재 빈도를 사용하는 두가지 방식이 있다
- 작업 집합 모델 : 최근 일정 시간동안 참조된 페이지들을 집합으로 만들고, 이 집합에 있는 페이지들을 물리 메모리에 유지한다
- 페이지 부재 빈도 : 페이지 부재 횟수를 기록하여 페이지 부재 비율을 계산하는 방식

##### 전역 교체와 지역 교체
- 전역 교체 : 전체 프레임을 대상으로 교체 알고리즘을 적용한다
- 지역 교체 : 현재 실행 중인 프로세스의 프레임을 대상으로 교체 알고리즘을 적용한다
- 지역 교체 방식은 다른 프로세스의 스레싱은 줄일 수 있지만 반대로 실행 중인 프로세스의 성능을 떨어뜨릴 수도 있기 때문에 전체 시스템의 입장에서는 전역 교체 방식이 지역 교체 방식 보다 효율적이다
