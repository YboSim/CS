## 프로세스의 개요

#### 프로세스의 정의
주변 장치에 정적으로 보관되어 있는 프로그램을 메모리에 올려 동적인 상태로 만드는것

#### 프로그램에서 프로세스로의 전환
- 운영체제가 저장장치에서 보관되어 있는 프로그램을 메모리의 적당한 위치로 가져온다
- 프로세스를 처리하는데 필요한 다양한 정보가 들어있는 PCB(프로그램 제어 블록)를 생성한다
- 프로세스 = 프로그램 + PCB

#### 프로세스의 상태
- 생성상태 : 프로세스가 메모리에 올라와 PCB를 생성해 실행준비가 완료된 상태
- 준비상태 : 생성된 프로세스가 CPU에 할당될때까지 기다리는 상태
- 실행상태 : 준비상태에서 CPU를 얻어 실제로 작업을 수행하는 상태로 주어진 시간 동안의 작업을 수행했을때 완전히 마치지 못한다면 준비상태로 돌아간다
- 완료상태 : 실행상태의 프로세스가 완전히 작업을 마치면 완료상태로 진입하는대 이 때 코드와 데이터 그리고 PCB를 폐기한다
- 대기상태 : 실행상태의 프로세스가 입출력을 요청하면 입출력이 완료될때 까지 기다리는 상태로 완료되면 현재 실행중인 상태인 다른 프로세스가 존재하기 때문에 준비상태로 돌아간다
- 휴식상태 : 프포레스가 작업을 일시적으로 쉬고있는 상태
- 보류상태 : 메모리에서 잠시 쫓겨난 상태로 아래와 같은 이유로 보류상태에 들어가는데, 대게 컴퓨터의 성능을 떨어뜨리거나 실행을 미루어도 큰 지장이 없는 프로세스가 해당된다
  1. 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보낼 때
  2. 프로그램에 오류가 있어서 실행을 미룰 때
  3. 바이러스와 같은 악의적인 공격을 하는 프로세스라 판단될 때
  4. 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
  5. 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때

![프로세스 상태](/Data/3-2.ProcessState.png)

## PCB와 문맥교환

#### PCB의 구성
- 포인터 : PBC를 연결하여 준비상태나 대기상태의 큐를 구현할 때 사용
- 프로세스 상태 : 생성, 준비, 실행, 대기, 보류준비, 보류대기등의 현재상태를 나타낸다
- 프로세스 구분자 : 운영체제내에 프로세스를 구별하기위한 구분자(식별자)
- 프로세스 카운터 : 다음 실행 될 명령어의 위치를 가리키는 값을 저장
- 프로세스 우선순위 : 프로세스들의 중요도에 따른 우선순의
- 각종 레지스터 정보
- 메모리 관리 정보 : 메모리의 어디에 있는지 나타내는 위치정보, 한계/경계 레지스터를 저장
- 할당된 자원 정보 : 프로세스 실행을 위한 입출력 자원이나 오픈 파일등에 대한 정보
- 계정 정보 : 계정번호, CPU할당시간, CPU사용시간
- PPID / CPID

![프로세스 구성](/Data/3-1.ProcessComponent.png)

#### 문맥교환
- CPU를 차지하던 프로세스가 나가고 세로운 프로세스를 할당하는 작업
- 두프로세스의 PCB를 교환하는 작업
- 문맥교환 예시<br/>
![문맥교환](/Data/3-3.ContextSwitching.png)
- 문맥교환에 걸리는 시간을 고려하여 타임슬라이스를 적당히 작게 설정하는 것이 중요하다

## 프로세스의 연산

#### 프로세스의 구조
- 코드영역(텍스트영역) : 프로그래머가 작성한 프로그램코드가 존재하는 영역으로 읽기전용으로 처리된다
- 데이터영역 : 코드실행에 사용하는 변수나 파일등의 각종 데이터가 존재하는 영역으로 읽기와 쓰기가 모두 가능하다
- 스택영역
  1. 커널이 유지하는 후입선출형 자료구조로 스테드가 작동하는 동안 추가되거나 삭제 되는 동적할당영역이다
  2. 함수가 호출될 때 종료후 되돌아올 메모리의 주소를 저장
  3. 지역변수같은 사용범위에 영향을 미치는 영역을 구현할 때 사용
- 힙영역
  1. 사용자가 직접 관리하는 메모리 영역
  2. 동적으로 할당되는 변수 영역<br/>
  
||스택|힙|
|:---|:---|:---|
|**특징**|-정적 메모리 할당<br/>-함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역<br/>-함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸<br/->푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출<br/>-후입선출(LIFO, Last-In First-Out) 방식<br/>-메모리의 높은 주소에서 낮은 주소의 방향으로 할당|-동적 메모리 할당<br/>-사용자가 직접 관리할 수 있는 ‘그리고 해야만 하는’ 메모리 영역<br/>-사용자에 의해 메모리 공간이 동적으로 할당되고 해제<br/>-메모리의 낮은 주소에서 높은 주소의 방향으로 할당|
|**장점**|-매우 빠른 액세스(할당,해제가 빠르다)<br/>-변수를 명시적으로 할당 해제 할 필요가 없다|-변수는 전역적으로 액세스 할 수 있다<br/>-메모리 크기 제한이 없다|
|**단점**|-메모리 크기 제한이 있다<br/>-미리 최대갯수 만큼의 저장공간을 확보해야 하기 때문에 저장공간의 낭비가 발생|-상대적으로 느린 액세스(할당,해제가 느리다)<br/>-메모리를 관리해야 한다.(변수를 할당하고 해제하는 책임이 있다)<br/>-운영체제마다 메모리 관리가 다르기 때문에 어렵다.|

## 프로세스의 생성,복사,전환 (시스템 호출)

```
void main()
{
    int pid;

    pid = fork(); //1번

    if(pid<0) {printf("Error");
               exit(-1);}

    else if(pid == 0) {
            printf("Child"); //2-1번
            exit(0); //2-2번

    else { Wait(Null); //3-1번
           printf("Parent"); //3-2번
           exit(0); } //4번
}
```
#### 프로그램 생성과 복사

- 주석 1번의 fork() 시스템 호출은 커널에서 제공하는 함수로 실행중인 함수로부터 새로운 프로세스를 복사하는 함수이다
- 이때 두 프로세스는 부모-자식 관계를 갖는다
- PID,PPID,CPID,메모리 관련 정보를 제외한 PCB내 대부분의 정보가 똑같다
- 장점(프로세스를 새로 만들지 않고 fork() 시스템 호출로 프로레스를 복사하는 이유)
  1. 프로세스의 생성 속도가 빠르다
  2. 추가 작업 없이 자원을 상속할 수 있다
  3. 시스템 관리를 효율적으로 할 수 있다

#### 프로그램 전환

- exec()시스템 호출은 기존프로세스를 세로운 프로세스로 전환하는 함수로 프로세스의 구조를 재활용하는 것
- PCB의 각종식별자는 변하지 않지만 나머지 각종정보들이 리셋되고 코드 영역에 있는 기존내용들 역시 지워지고 새로운 코드를 만든다

#### exit()와 Wait() 시스템 호출
- exit()함수를 통해 부모프로세스는 자식프로세스가 사용하던 자원을 빨리 거둬갈 수 있다
- wait()시스템 호출은 자식이 종료될 때까지 부모가 대기하는 모델에 사용된다
- 자식프로세스의 eixt()함수를 부모프로세스가 받지 않고 부모프로세스가 먼저 종료되면 자식프로세스의 exit()함수는 돌아갈 곳이 없으므로 자식프로세스가 고아프로세스가 되는것을 방지하기위해 사용된다

####  정리
- 주석 1번) fork()함수를 통해 부모프로세스(상기 코드)와 동일한 자식프로세스를 생성한다
- 주석 2-1번) 자식프로세스에서 printf() 함수를 통해 Child가 출력된다
- 주석 2-2번) 자식프로세스에서 exit()함수를 통해 부모프로세스에게 프로세스 종료를 알리고 부모프로세스에서 자식프로세스가 사용하던 자원을 거둬간다
- 주석 3-1번) Wait()함수가 없다면 자식프로세스와 부모프로세스는 독립적으로 실행되기 때문에 어떤 프로세스가 먼저exit()함수를 호출할지 모르지만 Wait()함수를 통해 자식프로세스가 먼저 종료 될때까지 기다린다(Wait()함수를 통해 자식프로세스가 고아프로세스가되는것을 방지한다)
- 주석 3-2번) 부모프로세스에서 printf() 함수를 통해 Parent가 출력된다
- 주석 4번) 부모프로세스가 종료된다

## 스레드

#### 스레드의 정의
- 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위

#### 스레드 vs 프로세스
- 프로세스는 여러개의 스레드를 가질 수 있다
- 프로세스는 스레드 실행의 틀이다
- 스레드는 스케쥴링의 최소 단위이다
- 프로세스는 정적이지만 스레드는 동적이다.

#### 프로세스의 작업 과정에서의 스레드
- 운영체제가 코드와 데이터를 메모리에 올려서 PCB를 생성하고 작업에 필요한 메모리 영역 확보한 후, 준비된 프로세스를 준비 큐에 삽입한다
- 프로세스가 생성되면 CPU스케줄러가 CPU에 스레드를 전달한다
- 운영체제 입장의 작업 단위는 프로세스이고 CPU 입장의 작업 단위는 스레드이다

#### 스레드 관련용어(기술)
- 멀티스레드 : 프로세스 내 작업을 여러개의 스레드로 분할함으로써 작업의 부담을 줄이는 프로세스 운영 기법
- 멀티태스킹 : 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법
- 멀티프로세싱 : CPU를 여러개 사용하여 여러개의 스레드를 동시에 처리하는 작업 환경 혹은 한개의 CPU내 여러개의 코어에 스레드를 배정하여 동시에 작업
- CPU멀티스레드 : 한번에 하나씩 처리해야 하는 스레드를 잘게 쪼개어 동시에 처리하는 명령어 병렬처리 기법(하이퍼스레드)

#### 멀티스레드의 구조 및 장,단점
- 1개의 프로세스내에서 정적인 영역인 코드,데이터등의 자원은 공유하고 여러개의 스레드를 생성사여 자원의 낭비를 막고 효율성을 향상시킨다
- 자원공유외에 응답성 향상, 다중CPU 지원등의 장점이있다
- 프로세스내에서 모든 스레드가 자원을 공유하기 때문에 한 스레드에 문제가 생기면 전체 프로세스에 문제가 생겨 종료되고 다른 스레드역시 파괴된다

![멀티스레드의구조](/Data/3-4.MultiThread.png)
