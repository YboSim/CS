## 메모리 관리 개요
메모리는 유일한 작업 공간이며 모든 프로그램은 하드디스크나 SSD와 같은 보조 저장장치에 보관되어 있다가 메모리로 올라와 프로세스가 된다

##### 메모리의 이해
- 메모리의 구조는 1바이트 크기로 나뉘며 나뉜 영역은 **주소**로 구분된다
- CPU는 메모리에 있는 데이터를 가져오거나 작업 결과를 메모리에 저장하기 위해 주소를 사용한다
- 주소는 CPU와 메모리 간 작업의 기준이 된다
- 메모리에 있는 데이터를 CPU로 가져오는 과정
  1) 접근하려는 메모리 주소를 메모리 주소 레지스터(MAR)에 넣으면 해당 주소가 주소 버스를 통해 메모리에 전달된다
  2) 메모리에서는 해당 주소의 값을 데이터 버스를 통해 메모리 버퍼 레지스터(MBR)로 보낸다
  3) 메모리 버퍼 레지스터(MBR)에 있는 데이터가 레지스터로 옮겨진다

##### 메모리 관리의 이중성
- 메모리 관리는 운영체제를 비롯해 여러 작업을 동시에 처리할 때 메모리를 어떻게 관리하는가에 관한 문제이다
- 프로세스 입장에서는 메모리를 독차지 하려하고, 메모리 관리자 입장에서는 관리를 효율적으로 하고자 하는데 이를 **메모리 관리의 이중성**이라고 한다. 즉, 프로세스 입장에서 작업의 편리함과 관리자 입장에서 관리의 편리함이 충돌하는 것
- 운영체제는 이러한 작업의 편리함과 관리의 편리함을 타협해 나가야 한다

##### 소스코드의 번역과 실행
- 프로그래밍 할 때 사람이 배우기 어렵고 이해하기 힘든 기계어가 아닌 고급언어(C언어/자바)를 사용한다
- 고급언어로 작성한 소스코드는 **컴파일러** 혹은 **인터프리터**를 통해 기계어로 번역된다
- 컴파일러 방식의 사용 목적/장점
  1) 소스코드에서 오류를 발견하여 실행 시 문제가 없도록 함
  2) 사용하지 않는 변수를 삭제하는것 과 같은 최적화를 함
  3) 컴파일러를 사용하는 프로그래밍 언어는 사용할 변수를 먼저 선언한 후 코드를 작성하는데 이는 오류를 찾고 코드를 최적화하기 위해 반드시 필요한 작업이다
- 컴파일러의 컴파일 과정
  1) 컴파일러는 소스코드에서 오류가 있는지 점검하고 최적화를 통해 필요 없는 변수와 코드를 삭제하여 **목적 코드**를 만든다
  2) 목적 코드가 만들어지면 라이브러리에 있는 코드를 목적 코드에 삽입하여 최종 실행 파일을 만든다
  3) 라이브러리란 자주 사용하는 함수를 시스템 내에 미리 만들어둔 것으로, 프로그래머가 직접 만들기 어렵거나 만드는데 시간이 많이 걸리는 함수를 파일 형태로 모아놓은 것
![컴파일]

##### 메모리 관리 작업
- 메모리 관리 작업은 **가져오기**, **배치**, **재배치**로 구분된다
- 메모리 가져오기 : 데이터를 메모리로 가져오는 작업. 일부 상황에서는 데이터의 일부만 가져와 실행하기도 한다(메모리의 크기가 프로세스의 크기보다 작을 때 등)
- 메모리 배치 : 배치작업전 메모리를 어떠한 크기로 잘라놓고 가져온 프로세스와 데이터를 메모리의 어떤 부분에 올려 놓을지  결정하는 작업
  1) 메모리를 같은(일정한) 크기로 자르는 것을 **페이징**이라고 한다
  2) 메모리를 프로세스의 크기에 맞게 자르는 것을 **세그먼테이션**이라고 한다.
- 메모리 재배치 : 꽉 찬 메모리에 새로운 프로세스를 가져오기 위해 기존에 있던 프로세스를 내보내는 작업

## 메모리 주소
메모리에 접근할 때는 주소를 이용한다. 메모리 주소는 **물리 주소**와 **논리 주소**로 나뉜다

##### 비트(bit)에 따른 메모리 주소 공간
- 비트(bit)는 CPU가 한번에 다룰 수 있는 데이터의 최대 크기이다
- 32bit CPU는 레지스터의 크기가 32bit이며 산술논리 연산장치, 각종 버스의 크기, 대역폭도 32bit이다. 즉, 대역폭의 버스를 통해 한번에 옮겨지는 데이터의 크기도 당연히 32bit이다
- 비트의 크기는 메모리 주소를 지정하는 레지스터인 메모리 주소 레지스터(MAR)의 크기와 같음으로 32bit이면 메모리 주소의 범위는 [0~2^32 - 1], 총 개수는 이다
- 따라서 32bit CPU컴퓨터는 2^32B, 약 4GB까지 사용할 수 있다

##### 논리 주소와 물리 주소
- 메모리 영역의 구분
  1) 메모리 관리자는 메모리를 운영체제 영역과 사용자 영역으로 나누어 관리한다
  2) 사용자 프로세스는 운영체제 영역을 피하여 사용자 영역에 적재된다
  3) 사용자 영역이 운영체제 영역으로 침범하는 것을 막는건 경계 레지스터가 담당한다

- 논리 주소와 물리 주소의 이해
  1) 물리 주소란 사용자 영역과 운영체제 영역을 포함한 메모리 전체 영역의 실제 주소로 메모리의 입장에서 바라본 주소이다
  2) 논리 주소란 운영체제 영역을 제외한 사용자 영역의 주소로 사용자 프로세스 입장에서 바라본 주소이다
  3) 논리 주소로 이루어진 프로세스를 실행하면 물리 주소로 변환하는 작업이 필요한대 이작업은 메모리 관리 유닛(MMU)이 담당한다

- 논리 주소를 물리 주소로 변환하는 과정
  1) 운영체제 영역은 0~359, 사용자 영역이 360~999, 재배치 레지스터의 주소값이 360, 논리 주소 40번지의 데이터에 접근하려고 한다고 가정해보자
  2) 사용자 프로세스가 논리 주소 40번지에 있는 데이터를 요청한다
  3) CPU는 메모리 관리 유닛에 40번지에 있는 내용을 가져오라고 명령한다
  4) 메모리 관리 유닛은 재배치 레지스터를 사용하여 메모리 400(360+40)번지에 저장된 데이터를 가져온다
![주소 변환]

## 단일 프로그래밍 환경의 메모리 할당

##### 메모리 오버레이
- 프로그램의 크기가 실제 메모리(물리 메모리)보다 클 때 전체 프로그램을 메모리에 가져오는 대신 적당한 크기로 잘라서 가져오는 기법을 **메모리 오버레이**라고 한다
- 메모리 오버레이는 프로그램을 몇 개의 모듈로 나누고 필요할 때마다 모듈을 메모리에 가져와 사용한다
- 메모리 오버리에에서 어떤 모듈을 가져오거나 내보낼지는 CPU레지스터 중 하나인 프로그램 카운터가 결정한다
![메모리 오버레이]

##### 스왑
- 메모리가 모자라서 쫗겨난 프로세스(기존에 메모리에 올라와있던 프로세스)를 저장장치의 특별한 공간에 모아두는데 이러한 영역을 **스왑 영역**이라고 한다
- 스왑영역에서 메모리로 가져오는 작업을 **스왑인**, 메모리에서 스왑영역으로 데이터를 내보내는 것을 **스왑아웃**이라고 한다
- 스왑영역은 하드디스크와 같은 저장장치에 존재하지만 메모리에서 쫓겨났다가 다시 돌아가는 데이터가 머무는 곳이기 때문에 메모리 관리자가 관리한다

## 다중 프로그래밍 환경의 메모리 할당

##### 메모리 분할 방식
- 메모리에 여러 개의 프로세스를 배치하는 방법은 **가변 분할 방식**과 **고정 분할 방식**이 있다
  1) 가변 분할 방식 : 프로세스의 크기에 따라 메모리를 나눈다
  ![가변 분할 방식]
  2) 고정 분할 방식 : 프로세스의 크기와 상관없이 메모리를 같은 크기로 나눈다
  ![고정 분할 방식]

##### 가변 분할 방식
- 프로세스의 크기에 맞게 메모리 크기를 분할하기 때문에 프로세스 한개가 한덩어리로 연속적으로 할당되어 **연속 메모리 할당**이라고 한다
- 세그먼테이션 메모리 관리 기법이라고도 한다
- 한 개의 프로세스를 연속적으로 한 공간에 배치한다는 장점이 있지만 메모리 관리가 복잡하다는 단점이 있다
- 예시로 10KB의 프로세스가 종료 되면 11KB이상의 프로세스를 할당할 수 없어 이렇게 빈 공간이 생기는 것을 **외부 단편화**라고 한다
- 외부 단편화로 인한 문제를 해결하기 위해 **메모리 배치 방식**이나 **조각 모음**을 사용한다
- 메모리 배치 방식
  1) 최초 배치 : 프로세스를 메모리에서 적재 가능한 공간을 순서대로 찾다가 첫번째로 발견한 공간에 프로세스를 배치하는 방식
  2) 최적 배치 : 메모리의 빈 공간을 모두 확인한 후 크키가 가장 비슷한 곳에 프로세스를 배치하는 방식
  3) 최악 배치 : 메모리의 빈 공간을 모두 확인한 후 크기가 가장 큰 곳에 프로세스를 배치하는 방식
![메모리 배치 방식]
- 조각 모음
  1) 조각 모음을 하기 위해 이동할 프로세스의 동작을 멈춘다
  2) 프로세스의 논리 주소 값을 바꾸고 적당한 위치로 이동한다
  3) 프로세스를 다시 시작한다
![조각 모음]

##### 고정 분할 방식
- 프로세스가 고정된 메모리 공간에 나누어 배치되기 때문에 **비연속 메모리 할당**이라고 한다
- 페이징 메모리 관리 기법이라고도 한다
- 메모리 관리가 간편하다는 장점이 있지만 일정하게 나뉜 메모리의 크기보다 작은 프로세스가 배치될 경우 낭비되는 공간이 생길 수 있다는 단점이 있다
- 각 메모리 조각에 프로세스를 배치하고 공간이 남는 것을 **내부 단편화**라고 한다
- 내부 단편화를 줄이기 위해 메모리를 어떤 크기로 나눌지 신중하게 결정해야 한다

##### 버디 시스템
- 가변 분할 방식의 단점인 외부 단편화를 완화하는 방법이다
- 버디 시스템의 작동 구조
  1) 프로세스 크기에 맞게 메모리를 1/2 자르고 프로세스를 메모리에 배치한다
  2) 나뉜 메모리의 각 구역에는 프로세스가 1개만 들어간다
  3) 프로세스가 종료되면 주변의 빈 조각과 합쳐서 하나의 큰 덩어리를 만든다
- 버디 시스템의 작동 구조 예시
  1) 16B 메모리에 2B크기의 프로세스가 올라오면 8B, 4B, 2B, 2B 크기의 공간으로 나누고  2B 크기의 메모리 공간에 배치된다
  2) 1B크기의 프로세스가 올라오면 비어있는 2B 크기의 공간을 1B, 1B 공간으로 나누고 1B 크기의 메모리 공간에 배치된다
  3) 1B크기의 프로세스가 종료되면 프로세스가 있던 1B크기의 공간과 비어있던 1B크기의 공간이 합쳐저 2B크기의 공간이 된다
- 버디 시스템의 특징
  1) 가변 분할 방식처럼 메모리가 프로세스 크기대로 나뉜다
  2) 고정 분할 방식처럼 하나의 구역에 다른 프로세스가 들어갈 수 없고 메모리의 한 구역 내부에 조각이 생겨 내부 단편화가 발생한다
  3) 상기 버디 시스템의 작동 구조 예시에 비어있는 1B크기의 공간이 내부 단편화에 해당한다
  4) 버디 시스템에서는 조각 모음을 하지 않아도 간단히 큰 덩어리를 만들 수 있다
