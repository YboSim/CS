## 1. 프로세스간 통신
프로세스는 독립적으로 실행되는데 이러한 프로세스간 사용하는 메모리 영역이 다르기 때문에 공유된 메모리를 통하여 통신하는 것이 쉽지 않다. 그래서 운영체제는 프로세스간 통신(IPC)을 제공해 쉽게 데이터를 주고 받을 수 있도록 한다.

### 1.1 프로세스간 통신의 분류

#### 1.1.1 통신방향에 따른 분류
- 양방향 : 데이터를 양쪽 방향으로 동시에 전송할 수 있는 구조. 일반적인 통신은 모두 양방향 통신
- 반양방향 : 데이터를 양쪽으로 전송할 수 있지만 동시 전송은 불가능하고 특정시점에 한쪽 방향으로만 전송할 수 있는 구조. 대표적으로 무전기가 이에 해당
- 단방향 : 한쪽 방향으로만 데이터를 전송할 수 있는 구조. 대표적으로 모스부호가 있다.

#### 1.1.2 통신 구현 방식에 따른 분류
- 동기화 통신 :  데이터를 받는 쪽은 데이터가 도착 할때까지 자동으로 대기상태에 머물러 있는 통신
- 비동기화 통신 : 데이터를 받는 쪽은 바쁜 대기를 사용 하여 데이터가 도착했는지 여부를 직접 확인하는 통신

비동기화 통신은 데이터를 받는쪽에서 보내는쪽이 데이터를 보냈는지 알 수 없기때문에 반복문을 무한 실행하며 기다리게 되는데, 이는 시스템 차원에서 자원 낭비가 크기 때문에 안좋은 프로그램의 예시가 될 수 있다.

### 1.2 프로세스간 통신의 종류

#### 1.2.1 파일을 이용한 통신
- 파일을 이용한 통신은 부모-자식 관계의 프로세스 간 통신에 많이 사용된다
- 운영체제에서 **프로세스 동기화를 제공하지 않기** 때문에 부모프로세스에서 Wait()함수를 통해 자식 프로세스의 작업이 끝날 때까지 기다렸다가 작업을 시작한다
- 파일 입출력 코드는 크게 열기(1), 쓰기(2), 읽기(3), 닫기(4) 4가지로 구성되어 있다
```
void main()
{
    int fd;
    char buf[5];

    fd=open("com.txt" , 0_RDWR); //1
    write(fd, "Test", 5);        //2
    read(fd, buf, 5);            //3
    close(fd);                   //4
    exit(0);
}
```
1) 파일열기 : open()는 일종의 준비 단계로 해당 파일에 접근 할 수 있도록 fd(file descriptor)를 반환한다. 첫번째 인자는 파일명이며 두번째 인자는 파일의 어떤작업을 할지 형태를 결정한다
2) 파일쓰기 : write(fd, "Test", 5);는 com.txt. 파일에 Test라는 문자열을 쓰라는 의미이다. 첫번째 인자는 파일디스크립터 두번째는 파일에 쓰기를 할 내용을 담은 버퍼 세번째는 쓰기할 바이트수 이다
3) 파일읽기 : read(fd, buf, 5)는 com.txt 파일에서 5B를 읽어 변수 buf에 저장하라는 뜻이다. 첫번째 인자는 파일디스크립터 두번째는 저장할 버퍼 변수 세번째는 읽을 바이트수 이다
4) 파일닫기 : close()는 파일을 닫는 함수이다. 인자는 파일디스크립터가 가리키는 파일, 즉 com.txt 파일을 닫는다

#### 1.2.2 파이프를 이용한 통신
![파이프통신](/Data/5-1.Pipe.png)
- 운영체제가 제공하는 **동기화 통신 방식**으로 하나의 프로세스는 데이터를 쓰기만하고 다른프로세스는 데이터를 읽기만하는 **단방향 통신**이다
- 데이터 읽기와 쓰기 모두 하기를 원한다면 두개의 파이프를 만들어야 가능하지만 구현이 복잡해 질 수 있다
- 파일을 이용한 통신과 마찬가지로 open함수로 fd를 얻어 작업하고 close함수로 마무리한다
- 파이프는 **이름 없는 파이프**와 **이름 있는 파이프**로 나뉜다
  1) 이름 없는 파이프 : 부모와 자식 프로세스 혹은 부모를 가진 자식 프로세스와 같이 서로 관련 있는 프로세스간 통신에 사용된다
  2) 이름 있는 파이프 : FIFO라 불리는 특수 파일을 이용하며 서로 관련 없는 프로세스간 통신에 사용된다

#### 1.2.3 소켓을 이용한 통신
![소켓통신](/Data/5-2.Socket.png)
- 서버-클라이언트간 데이터를 주고 받을 때 주로사용되는 **양방향 통신**이다
- 소켓은 클라이언트소켓과 서버소켓으로 구분되며, 소켓간 통신을 위해서는 네트워크상에서 클라이언트와 서버에 해당되는 컴퓨터를 식별하기 위한 **IP주소**와 해당컴퓨터내에서 현재 통신에 사용되는 프로세스를 식별하기 위한 **포트번호**가 사용된다
- 소켓을 이용한 통신에서도 open(), read(), write(), close()구조를 사용한다
- 소켓을 이용한 통신 절차
  1) 서버측에서 socket()함수를 통해 소켓을 생성하여 bind()를 사용하여 생성한 소켓을 특정 포트에 등록한다
  2) 생성된 소켓이 정상적으로 등록되면 listen()을 실행하여 클라이언트를 받을 수 있는 상태를 만든다
  3) 클라이언트측에서도 socket()함수를 통해 소켓을 생성하고 connect()를 사용하여 서버 접속을 시도한다
  4) 서버측에서 accept()를 통해 클라-서버간 연결을 수락한다
  5) 서버와 클라이언트간 read()와 wirte()를 통해 작업을 진행한다
  6) 작업이 종료되면 클라이언트측에서 close()를 통해 소켓 기술자를 닫는다

#### 1.2.4 프로세스간 통신의 종류 정리
|구분|동기화 지원 여부|통신 방향|
|:---|:---|:---|
|파일을 이용한 통신|X|단방향|
|파이프를 이용한 통신|O|단방향|
|소켓을 이용한 통신|O|양방향|

## 2. 공유 자원과 임계 구역

#### 2.1 공유 자원에 대한 접근
- 공유자원이란 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 뜻한다
- 2개 이상의 프로세스가 공유자원을 병행해서 읽거나 쓰는 상황인 **경쟁 조건**이 발행할 수 있기 때문에 공유 자원 접근 순서를 정하여 예상치 못한 문제가 발생하지 않도록 해야 한다

#### 2.2 임계 구역

##### 2.2.1 임계 구역의 정의
- **임계 구역**(critical section)이란 공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역을 뜻한다

##### 2.2.2 임계 구역 해결 조건
- 상호 배제 : 한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역에 들어갈 수 없다
- 한정 대기 : 어떤 프로세스도 임계구역에 진입하지 못하여 무한대기하지 않아야 한다
- 진행의 융통성 : 한 프로세스가 다른 프로세의 진행을 방해해서는 안된다

#### 2.3 임계 구역 해결 방법
- 기본 코드
```
//공유 변수
boolean lock = false;

//프로세스 P1
while(lock == true);
lock = true;
//임계 구역
    ...
//임계 구역
lock false;

//프로세스 P2
while(lock == true);
lock = true;
//임계 구역
    ...
//임계 구역
lock = false;
```
- 위 기본 코드의 상호 배제 문제
  1) P1이 while(lock == true)문을 실행하고 타임아웃이 되어 CPU를 잃으면 P2 프로세스가 실행된다
  2) P1에서 lock = true문을 실행하지 못햇기 때문에 P2 프로세스가 while(lock == true)문을 넘어가고 임계 구역에 진입한다
  3) P1에서도 lock = true문을 실행에 잠금을걸고 임계구역에 진입한다
  4) 결국 둘다 임계구역에 진입하게 된다
- 위 기본 코드의 바쁜대기 문제
  1) P1이 lock = true문을 실행하고 임계 구역에 진입한다
  2) P2이 while(lock == true)문을 만나 작업을 할 수 없는 상황에서도 무한루프를 돌면서 바쁜대기를하며 시스템 자원을 낭비하게 된다

##### 2.3.1 피터슨 알고리즘
- 코드
```
//공유 변수
boolean lock1 = false;
boolean lock2 = false;
int turn = 1;

//프로세스 P1
lock1 = true;
turn = 2;
while(lock2 == true && turn == 2);
//임계 구역
    ...
//임계 구역
lock1 = false;

//프로세스 P2
lock2 = true;
turn = 1;
while(lock2 == true && turn == 2);
//임계 구역
    ...
//임계 구역
lock2 = false;
```

- 위 코드는 임계구역의 문제 해결을 위한 3가지 조건을 만족하는 코드이다
  1)P1에서 lock1 = true문을 통해 잠금을 걸고 turn을 2로 설정한다
  2)turn은 두프로세스가 동시에 lock을 설정하여 임계구역에 못들어가는 상황에 대비하기 위한 장치이다
  3)두 프로세스가 lock1 = true와 lock2 = true문을 통해 동시에 잠금을 설정했더라도 turn을 사용하여 다른프로세스에 양보한다
- 피터슨 알고리즘은 임계구역 문제 해결을 위한 3가지 조건을 모두 만족하지만 2개의 프로세스만 사용가능하다
- 2개의 프로세스가 아닌 더많은 프로세스에서 사용하려고 하면 공유 변수를 추가하고 코드를 변경해야 한다

#### 2.3.2 데커 알고리즘
- 코드
```
//공유 변수
boolean lock1 = false;
boolean lock2 = false;
int turn = 1;

//프로세스 P1
lock1 = true;
while(lock2 == true)
{  if(turn == 2)
   {
       lock1 = false;
       while(trun==2);
       lock1 = true;
   }
}
//임계 구역
    ...
//임계 구역
turn=2;
lock1 = false;

//프로세스 P2
lock2 = true;
while(lock1 == true)
{  if(turn == 1)
   {
       lock2 = false;
       while(trun==1);
       lock2 = true;
   }
}
//임계 구역
    ...
//임계 구역
turn=1;
lock2 = false;
```
- 데커 알고리즘은 임계구역 문제 해결의 세가지 조건을 모두 만족하지만 프로세스가 늘어나면 변수도 늘어나고 알고리즘이 복잡해진다는 단점이 있다
  1) P1에서 lock1 = true문을 통해 잠금을 걸고 while(lock2 == true)문을 통해 P2의 잠금이 걸려있는지 확인한다
  2) if(turn == 1)문을 통해 P1의 차례인지 P2의 차례인지 확인한 후 P1의 차례라면[if(turn==1)] 임계구역에 진입한다
  3) P2의 차례라면[if(turn==2] lock1 =false문을 통해 잠금을 해제하고 while(trun==2)문을 통해 P2가 작업을 끝낸뒤 turn을 넘겨줄 때까지 기다린 후 lock1=true문을 통해 다시 잠금을 걸고 임계구역에 진입한다

#### 2.3.3 세마포어
- 코드
```
Semaphore(n); // RS = n;

P(); // if RS > 0 then RS = RS -1;
     // else block();

//임계구역
   ...
//임계구역

V(); // RS = RS + 1;
        wake_up();
```
- 앞서 나온 알고리즘은 바쁜대기를 사용하여 자원을 낭비하거나 알고리즘이 너무복잡하기 때문에 이러한 단점을 해결하기 위해 제안되었다
- 세마포어 알고리즘에서는 block()과 wake_up()을 통해 바쁜대기를 사용하지않아도 된다
  1) Semaphore(n)문을 통해 전역 변수 RS를 n으로 초기화 한다(n은 현재 사용 가능한 자원의 수)
  2) P()문을 통해 사용가능한 자원이 있는지 확인[if(RS > 0)] 한 후 있으면 1만큼 감소 시키고 임계구역에 진입한다
  3) 없으면 block()을 통해 사용가능한 자원이 있을때 까지 대기한다
  4) V()문을 통해 사용한 자원을 다시 되돌려[RS = RS +1]주고 기다리는 프로세스에게 wake_up()문을 통해 임계구역에 진입해도 좋다는 신호를 보낸다
- 세마포어 알고리즘은 공유자원이 여러 개일 때도 사용할 수 있고 복잡하지 않다는 장점이 있지만 사용자가 고의 혹은 실수를 했을 경우 임계구역을 보호받지 못한다는 단점이 있다
