## 1. 프로세스간 통신
프로세스는 독립적으로 실행되는데 이러한 프로세스간 사용하는 메모리 영역이 다르기 때문에 공유된 메모리를 통하여 통신하는 것이 쉽지 않다. 그래서 운영체제는 프로세스간 통신(IPC)을 제공해 쉽게 데이터를 주고 받을 수 있도록 한다.

### 1.1 프로세스간 통신의 분류

#### 1.1.1 통신방향에 따른 분류
- 양방향 : 데이터를 양쪽 방향으로 동시에 전송할 수 있는 구조. 일반적인 통신은 모두 양방향 통신
- 반양방향 : 데이터를 양쪽으로 전송할 수 있지만 동시 전송은 불가능하고 특정시점에 한쪽 방향으로만 전송할 수 있는 구조. 대표적으로 무전기가 이에 해당
- 단방향 : 한쪽 방향으로만 데이터를 전송할 수 있는 구조. 대표적으로 모스부호가 있다.

#### 1.1.2 통신 구현 방식에 따른 분류
- 동기화 통신 :  데이터를 받는 쪽은 데이터가 도착 할때까지 자동으로 대기상태에 머물러 있는 통신
- 비동기화 통신 : 데이터를 받는 쪽은 바쁜 대기를 사용 하여 데이터가 도착했는지 여부를 직접 확인하는 통신

비동기화 통신은 데이터를 받는쪽에서 보내는쪽이 데이터를 보냈는지 알 수 없기때문에 반복문을 무한 실행하며 기다리게 되는데, 이는 시스템 차원에서 자원 낭비가 크기 때문에 안좋은 프로그램의 예시가 될 수 있다.

### 1.2 프로세스간 통신의 종류

#### 1.2.1 파일을 이용한 통신
- 파일을 이용한 통신은 부모-자식 관계의 프로세스 간 통신에 많이 사용된다
- 운영체제에서 **프로세스 동기화를 제공하지 않기** 때문에 부모프로세스에서 Wait()함수를 통해 자식 프로세스의 작업이 끝날 때까지 기다렸다가 작업을 시작한다
- 파일 입출력 코드는 크게 열기(1), 쓰기(2), 읽기(3), 닫기(4) 4가지로 구성되어 있다
```
void main()
{
    int fd;
    char buf[5];

    fd=open("com.txt" , 0_RDWR); //1
    write(fd, "Test", 5);        //2
    read(fd, buf, 5);            //3
    close(fd);                   //4
    exit(0);
}
```
1) 파일열기 : open()는 일종의 준비 단계로 해당 파일에 접근 할 수 있도록 fd(file descriptor)를 반환한다. 첫번째 인자는 파일명이며 두번째 인자는 파일의 어떤작업을 할지 형태를 결정한다
2) 파일쓰기 : write(fd, "Test", 5);는 com.txt. 파일에 Test라는 문자열을 쓰라는 의미이다. 첫번째 인자는 파일디스크립터 두번째는 파일에 쓰기를 할 내용을 담은 버퍼 세번째는 쓰기할 바이트수 이다
3) 파일읽기 : read(fd, buf, 5)는 com.txt 파일에서 5B를 읽어 변수 buf에 저장하라는 뜻이다. 첫번째 인자는 파일디스크립터 두번째는 저장할 버퍼 변수 세번째는 읽을 바이트수 이다
4) 파일닫기 : close()는 파일을 닫는 함수이다. 인자는 파일디스크립터가 가리키는 파일, 즉 com.txt 파일을 닫는다

#### 1.2.2 파이프를 이용한 통신
![파이프통신](/Data/5-1.Pipe.png)
- 운영체제가 제공하는 **동기화 통신 방식**으로 하나의 프로세스는 데이터를 쓰기만하고 다른프로세스는 데이터를 읽기만하는 **단방향 통신**이다
- 데이터 읽기와 쓰기 모두 하기를 원한다면 두개의 파이프를 만들어야 가능하지만 구현이 복잡해 질 수 있다
- 파일을 이용한 통신과 마찬가지로 open함수로 fd를 얻어 작업하고 close함수로 마무리한다
- 파이프는 **이름 없는 파이프**와 **이름 있는 파이프**로 나뉜다
  1) 이름 없는 파이프 : 부모와 자식 프로세스 혹은 부모를 가진 자식 프로세스와 같이 서로 관련 있는 프로세스간 통신에 사용된다
  2) 이름 있는 파이프 : FIFO라 불리는 특수 파일을 이용하며 서로 관련 없는 프로세스간 통신에 사용된다

#### 1.2.3 소켓을 이용한 통신
![소켓통신](/Data/5-2.Socket.png)
- 서버-클라이언트간 데이터를 주고 받을 때 주로사용되는 **양방향 통신**이다
- 소켓은 클라이언트소켓과 서버소켓으로 구분되며, 소켓간 통신을 위해서는 네트워크상에서 클라이언트와 서버에 해당되는 컴퓨터를 식별하기 위한 **IP주소**와 해당컴퓨터내에서 현재 통신에 사용되는 프로세스를 식별하기 위한 **포트번호**가 사용된다
- 소켓을 이용한 통신에서도 open(), read(), write(), close()구조를 사용한다
- 소켓을 이용한 통신 절차
  1) 서버측에서 socket()함수를 통해 소켓을 생성하여 bind()를 사용하여 생성한 소켓을 특정 포트에 등록한다
  2) 생성된 소켓이 정상적으로 등록되면 listen()을 실행하여 클라이언트를 받을 수 있는 상태를 만든다
  3) 클라이언트측에서도 socket()함수를 통해 소켓을 생성하고 connect()를 사용하여 서버 접속을 시도한다
  4) 서버측에서 accept()를 통해 클라-서버간 연결을 수락한다
  5) 서버와 클라이언트간 read()와 wirte()를 통해 작업을 진행한다
  6) 작업이 종료되면 클라이언트측에서 close()를 통해 소켓 기술자를 닫는다

#### 1.2.4 프로세스간 통신의 종류 정리
|구분|동기화 지원 여부|통신 방향|
|:---|:---|:---|
|파일을 이용한 통신|X|단방향|
|파이프를 이용한 통신|O|단방향|
|소켓을 이용한 통신|O|양방향|

###
