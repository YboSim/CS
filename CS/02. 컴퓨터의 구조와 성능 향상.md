## 컴퓨터의 기본구성

- 필수장치 : 중앙처리장치(CPU), 메인메모리
- 주변장치 : 입력장치, 출력장치, 저장장치
- 위의 필수장치와 주변장치를 연결하고 전원을 공급해주는 커다란판을 **메인보드**라고 한다.
- 메인보드에서 각장치를 연결하여 데이터가 지나다니는 통로를 **버스**라고한다.
- 버스는 시스템버스와 CPU버스로 나눌 수 있다
  1. 시스템버스(FSB) : 메모리와 주변장치를 연결하는 버스(메인보드의 동작 속도)
  2. CPU버스(BSB) : CPU내부의 장치들을 연결하는 버스

## CPU와 메모리

#### CPU = 산술논리 연산장치(ALU) + 제어장치(control unit) + 레지스터(register)
  산술논리 연산장치 : 데이터의 덧셈,뺄셈,곱셈,나눗셈과 같은 산술연산과 AND,OR과 같은 논리연산을 수행
  <br/>제어장치 : 작업을 지시하는 부분
  <br/>레지스터 : 작업에 필요한 데이터를 CPU내부에 보관하는 곳

- 레지스터는 데이터 레지스터와 주소 레지스터로 나눌 수 있다
  1. 데이터 레지스터(DR) : 메모리에서 가져온 데이터를 임시로 보관할 때 사용
  2. 주소 레지스터(AR) : 데이터 또는 명령어가 저장된 메모리의 주소를 보관할 때 사용

- 데이터 레지스터와 주소 레지스터외에 특별한 용도로 존재하는 **특수레지스터**가 존재한다.
  1. 프로그램 카운터(PC) : 어떤 명령어를 처리할지, 몇행의 명령어를 실행할지 저장하는 레지스터(명령어의 주소를 기억하고 있다가 제어장치에 알려준다)
  2. 명령어 레지스터(IR) : 현재 실행중인 명령어를 저장하는 레지스터(제어장치에서 명령어 레지스터에 있는 명령을 해석해 외부장치에 제어신호를 보낸다)
  3. 메모리 주소 레지스터(MAR) : 메모리에서 데이터를 주고 받을때 주소를 저장하는 레지스터(메모리가 관리자가 MAR에 담겨있는 메모리 주소를 읽고 해당위치에 데이터를 저장한다)
  4. 메모리 버퍼 레지스터(MBR) : 메모리에서 가져온 데이터 혹은 메모리로 갈 데이터를 임시로 저장하는 레지스터(항상 MAR와 함께 동작한다)
  5. 프로그램 상태 레지스터(PSR) : 연산결과를 저장하는 레지스터(실행중인 명령어의 연산결과를 임시로 저장하고 다음으로 몇번행으로 이동할지 제어장치에 전달한다)

#### 시스템 버스의 종류
- 제어버스 : 다음에 어떤작업을 할지 지시하는 제어신호가 오가는 버스
     <br/>제어장치 ↔ 제어버스 ↔ 주변장치/메모리
- 주소버스 : 메모리를 읽고 쓸때 메모리의 주소가 오고가는 버스
     <br/>메모리주소레지스터(MAR) ↔ 주소버스 ↔ 주변장치/메모리
- 데이터버스 : 데이터가 오가는 버스
     <br/>메모리버퍼레지스터(MBR) ↔ 데이터버스 ↔ 주변장치/메모리

![FSB](/Data/2-1.FSB.png)

- 버스에서 오가는 데이터의 최대 크기를 버스의 대역폭이라고 하고 초기의 컴퓨터는 8bit 대역폭에서 64bit까지 발전했다.
  
#### 메모리의 종류
- RAM(Random Access Memory) : 읽고 쓸 수 있는 메모리
- ROM(Read Only Memory) : 읽기만 가능한 메모리
 
![Memory](/Data/2-2.Memory.png)

- 휘발성 램(비화발성에 비해 불편하지만 비교적 메모리 내부가 간단하고 속도가 빨라 메인메모리는 휘발성 메모리를 사용)
  1. DRAM : 저장된 0과 1의 데이터가 일정시간이 지나면 사라지므로 일정시간마다 다시 재생시켜야한다.
  2. SRAM : 전력이 공급되는 동안 데이터를 보관할 수 있어 재생할 필요가 없다.
  3. SDRAM : 클록틱이 발생할 때마다 데이터를 저장하는 동기 DRAM이다.

- 비휘발성 램
  1. 플래시 메모리 : 전력이 없이도 데이터를 보관가능한 메모리(각 소자에 최대사용횟수가 있어 천번~만번 사용하면 제 기능을 잃는다)
  2. FRAM : 프로그램 수행 중 새로 획득한 정보, 변할 수 있는 컴퓨터 동작에 필요한 데이터(변수 등)을 저장하는 역할

- 롬
  1. PROM : 사용자에 의해 전용기계를 이용하여 데이터를 한번만 저장할 수 있음(변경,삭제 불가능)
  2. 마스크 롬 : 제조과정에 이미 내용을 미리 기억시켜놓은 메모리로 사용자가 내용을 변경할 수 없음
  3. EPROM : 프로그래밍 가능하며 장비를 이요하여 쓰고 지우기가 가능하며 속도가 빠르나 비효율적이고 가격도 비싸다.

#### 메모리 보호
- 일괄작업 시스템에서는 메모리가 운영체제 영역과 사용자 영역으로 구분된다.
- 사용자 영역에서 운영체제 영역으로 침범하지 못하게 메모리 시작 주소를 경계 레지스터에 저장한 후 작업을 시작한다.
- 현재 진행중인 작업이 차지하고 있는 메모리의 크기를 한계 레지스터에 저장한다.
- 작업진행 중 두 레지스터의 범위를 벗어나는지 점검하여 메모리를 보호한다.

#### 부팅
- 운영체제도 CPU에 의해 실행되는 프로그램이기 때문에 메모리에 올라와야한다.
- 롬에 저장된 바이오스실행 → 하드웨어 점검 → 마스터 부트 레코드에 저장된 부트스트랩을 가져와 실행 → 부트스트랩 코드가 운영체제 프로세스 실행
- 운영체제가 2개인 컴퓨터에서는 부트스트랩 실행 후 어떤 운영체제를 사용할 것인지 확인한다.

## 컴퓨터 성능 향상 기술
컴퓨터 구조의 가장큰 문제는 CPU, 메모리, 주변장치 간 작업속도가 다르다는 것이라 장치간 속도차이를 완화시키는 것이 가장 중요하다.

#### 버퍼
- 일정량의 데이터를 모아서 한번에 옮기는 방식

#### 스풀
- CPU와 입력장치가 독립적으로 동작하도록 고안된 소프트웨어적 버퍼
- Ex) 프린터에 사용되는 스풀러

#### 캐시
- 메모리 데이터를 미리 가져와 임시적으로 저장하는 장소
- CPU는 메모리보다 훨씬 빠르기 때문에 메모리에서 미리 데이터를 가져다 놓고 필요 시 캐시를 방문해 원하는 데이터가 있는지 확인한다.
- 있으면 캐시히트라 하고 없으면 캐시미스라 하는대 캐시히트가 되는 비율인 캐시적중률을 높여 성능을 향상시킬 수 있다.
- 적중률을 높이는 방법에는 캐시의 크기를 늘리는 방법과 지역성이론에 따라 가까운 데이터를 더 많이 가져온다.
- 캐시에 있는 데이터가 변경되면 메모리에 반영시켜야 하는데 즉시 쓰기 방식과 지연쓰기 방식이 있다.
  1. 즉시쓰기 : 캐시에 있는 데이터 변경 시 즉시 메모리에 반영
  2. 지연쓰기 : 변경된 내용을 모아 주기적으로 메모리에 반영(성능향상에는 효율적이나 오류가 일어날 가능성이 있다)
- 메모리 → 캐시 → 명령어 캐시 → 명령어 레지스터
- 메모리 → 캐시 → 데이터 캐시 → 데이터 레지스터

#### 저장장치 계층구조
- 속도가 빠르고 값이 비싼 저장장치를 CPU에 가까운 쪽에 두고 값이 싸고 용량이 큰 저장장치를 반대쪽에 배치하는 방법

#### 인터럽트
- CPU가 직접 데이터를 가져오고 가져다두는 방식인 폴링 방식과 다르게 CPU작업과 데이터 이동을 독립적으로 운영하는 방식
- CPU가 입출력관리자에게 데이터 이동을 명령하고 작업을 진행하다 데이터 이동 완료를 보고받으면 옮겨진 데이터를 처리한다.

#### 직접메모리 접근
- 메모리에 접근할 수 있는 CPU에게 허가받지 않고 입출력장치가 직접메모리에 접근하는 것

#### 메모리 맵 입출력
- 입출력 장치가 메모리에 아무렇게나 데이터를 저장하면 CPU가 사용하는 데이터와 섞여 관리가 힘들어지기 때문에 메모리 영역을 CPU작업영역과 입출력 작업영역으로 나누어 할당하는 기법

#### 사이클 훔치기
- CPU와 입출력 관리자가 동시에 메모리에 접근하면 비교적 작업속도가 느린 입출력 관리자에게 권한을 양보하고 그 이후에 CPU가 접근하는 방식

## 멀티 프로세싱
- CPU의 클록을 높이면 발열 문제가 일어나기 때문에 5GHz를 넘는 CPU개발이 어려워 핵심기능을 가진 코어를 여러개 만드는 것을 **멀티코어 시스템**이라고 한다.
- 멀티코어 시스템과 프로세서를 여러개 설치하여 사용하는 사용하는 시스템을 **멀티프로세서 시스템**이라고 한다.
- 하나의 코어에서 2개이상의 명령어를 처리하는 방법을 **명령어 병렬처리**라고 한다.
- 하나의 코어에서 여러개의 스레드를 이용하는 방식을 **CPU멀티스레드**라고 한다.
- 위의 방식을 한번에 구현하여 멀티코어와 명령어 병렬처리기능을 한번에 구현할 수 있다.
- Ex)쿼드코어와 명령어 병렬처리를 동시에 사용하면 4x2로 8개의 프로세스를 진행시킬 수 있어 코어가 8개 존재하는 CPU처럼 보일 수 있다.
