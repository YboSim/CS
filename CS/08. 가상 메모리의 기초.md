## 가상 메모리의 개요

##### 가상 메모리 시스템
- 가상 메모리는 크기가 다른 물리 메모리에서 일관되게 프로세스를 실행할 수 있는 기술이다. 즉, 물리 메모리의 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공하는 것
- 물리 메모리의 크기와 프로세스가 올라갈 메모리의 위치를 신경 쓰지 않고 프로그래밍하도록 지원한다
- 가상 메모리의 최대크기는 컴퓨터 시스템이 가진 물리 메모리의 최대 크기, CPU 비트에 따라 결정된다(32bit CPU의 경우 2^32-1, 최대 약 4GB의 메모리를 갖을 수 있다)
- 실제 존재하는 물리메모리가 부족하면 하드디스크에 존재하는 스왑 영역으로 보충한다
- 가상 메모리 시스템에서 메모리 관리자는 물리 메모리와 스왑영역을 합쳐서 프로세스가 사용하는 가상 주소를 실제 메모리의 물리 주소로 변환하는데, 이를 **동적 주소 변환**이라고 한다

##### 메핑 테이블
- 메모리 관리를 수월하게 하기 위해 가상 주소와 물리 주소를 일대일로 매핑한 것을 **매핑 테이블**이라고 한다
- 메핑 테이블을 통해 가상 주소가 실제 물리 메모리에서 어느 위치에 있는지 알 수 있다
- 가변 분할 방식을 이용한 메모리 관리 기법은 **세그먼테이션**이라 하고 세그먼테이션 기법에서 사용하는 메핑 테이블을 **세그먼테이션 매핑 테이블**이라고 한다
- 고정 분할 방식을 이용한 메모리 관리 기법은 **페이징**이라 하고 페이징 기법에서 사용하는 메핑 테이블을 **페이지 매핑 테이블**이라고 한다

##### 지역성
- 기억장치에 접근하는 패턴이 메모리 전체에 고루 분포되는 것이 아니라 특정 영역에 집중되는 성질
- 공간의 지역성, 시간의 지역성, 순차적 지역성으로 나뉜다
  1) 공간의 지역성 : 현재 위치에서 가까운 데이터에 접근할 확률이 먼 거리에 있는 데이터에 접근할 확률보다 높음
  2) 시간의 지역성 : 현재를 기준으로 가장 가까운 시간에 접근한 데이터가 더 먼 시간에 접근한 데이터보다 사용될 확륙이 높음
  3) 순차적 지역성 : 일반적으로 프로그래밍은 앞에서부터 순차적으로 진행된다(순차적 지역성은 공간의 지역성의 특별한 경우로 보기도 함)
- 캐시 적중률을 높이는 것과 변환 색인 버퍼(TLB) 적중률을 높이는 것을 지역성과 연관지어 생각할 수 있다

## 페이징 기법

##### 페이징 기법의 구현
- 고정 분할 방식을 이용한 가상 메모리 관리 기법으로 물리 주소 공간을 같은 크기로 나누어 사용한다
- 가상 메모리 공간의 분할된 영역을 **페이지**라고 부르며 물리 메모리의 분할된 영역을 **프레임**이라고 부른다. 각 페이지와 프레임 영역은 번호를 매겨 관리한다
- 페이지 테이블은 하나의 열로 구성되고 0번째 행부터 순서대로 페이지0 가상주소의 실제 물리 메모리의 주소인 물리 주소를 나타낸다. 물리 메모리에 올려져 있지 않는 페이지는 페이지 테이블에 물리 주소가 아닌 'invalid'로 표기한다

##### 페이징 기법의 주소 변환
![페이징 기법의 주소 변환](/Data/8-1.Page.png)
- 상기 이미지를 예시로 들어 주소 변환 과정을 설명
  1) 가상 주소 30번이 어느 페이지에 있는지 확인한다. 30번은 페이지 3번의 0번 위치에 있다
  2) 페이지 테이블에서 가상 주소 30번이 있는 페이지가 몇번 프레임에 있는지 확인한다. 가상 주소30번은 프레임1에 존재한다
  3) 가상 메모리와 물리 메모리는 같은 크기로 나눠져 있기 때문에 가상 주소30번은 프레임1 0번 위치에 있다
- 페이징 기법에서는 가상주소를 VA = <P, D>로 표기한다. (VA - virtual address, P - page, D - 페이지의 처음 위치에서 해당 주소까지 distance)
- 페이징 기법에서는 물리주소를 PA = <F, D>로 표기한다. (PA - ahysical address, F - frame D - 프레임의 처음 위치에서 해당 주소까지 distance)
- 즉, 가상 주소 30번은 VA = <3, 0> / PA = <1, 0>로 표기할 수 있다
- P = (가상 주소 / 한 페이지의 크기)의 몫, D = (가상 주소 / 한 페이지의 크기)의 나머지로 정리 할 수 있다

##### 페이지 테이블 관리
- 시스템에 여러개의 프로세스가 존재하고 프로세스마다 페이지 테이블이 하나씩 있기 때문에 페이지 테이블 관리가 복잡하다
- 페이지 테이블은 메모리 관리자가 자주 사용하는 자료구조로 필요 시 빨리 접근할 수 있어야 하므로 물리 메모리 영역 중 운영체제 영역의 일부분에 모아놓는다
- 페지이 테이블에 빠르게 접근하기 위해 PCB내에 **페이지 테이블 기준 레지스터(PTBR)** 가 존재한다
- 메모리에 올라온 프로세스가 많아지면 그만큼 페이지 테이블이 많아지므로 운영체제 영역의 메모리가 커져 사용자 영역의 메모리가 작아진다. 그렇기 때문에 페이지 테이블의 크기를 적정하게 유지하는 것이 중요하다

##### 쓰기 시점 복사
- 크롬 브라우저 프로세스 A,B 2개가 있다고 가정하면 각 프로세스는 같은 크롬 브라우저이기 때문에 일부 데이터 영역을 공유할 수 있다
- fork()문을 사용하여 프로세스를 복사하면 공유할 수 없는 데이터를 저장하기 위한 메모리 공간은 미리 확보하지 않고 데이터 변화가 있을 때까지 복사를 미루는 **쓰기 시점 복사**를 한다
- 예시
  1) 구글 홈페이지를 보고있는 두개의 프로세스 A,B가 있다
  2) B프로세스가 구글 홈페이지에서 네이버 홈페이지로 이동하면 공유할 수 없는 프레임이 생길수 밖에 없다
  3) 이와 같이 데이터 변화가 있을때 새로운 프레임 공간을 확보한다

##### 변환 색인 버퍼(TLB)
- 가상 주소를 물리 주소로 변환하는 작업은 CPU안에 있는 **메모리 관리 유닛(MMU)** 이 담당한다
- 메모리 관리 유닛이 가상 주소를 받아 물리 유닛으로 변환하는 과정을 거쳐 물리 메모리에 접근하면 굉장히 많은 시간이 걸리기 때문에 메모리에 존재하는 페이지 테이블의 일부를 CPU내부로 가져오게 되는대, 이를 **변환 색인 버퍼**라고 한다
- 변환 색인 버퍼는 캐시 시스템과 비슷한 방식이기 때문에 연관지어 생각하면 이해하기 쉽다
- 변환 색인 버퍼 동작 방식
  1) 주소 변환을 위해 변환 색인 버퍼를 찾아 원하는 페이지 번호가 있는지 확인한다
  2) 페이지 번호가 있으면 TLB히트라고 하며, 곧바로 물리 주소로 변환된다
  3) 페이지 번호가 없으면 TLB미스라고 하며, 메모리에 있는 페이지 테이블을 사용하여 물리 주소로 변환한다

##### 역 페이지 테이블
- 기존 페이지 방식과는 반대로 페이지 테이블을 구성하는대 프레임 번호를 기준으로 물리 메모리의 프레임에 어떤 프로세스의 어떤 페이지가 올라와 있는지 표시한다
- 행 순서대로 0 - n 프레임이고 1열은 PID를 나타내며 2열은 몇 페이지인지를 나타낸다
- 역 페이지 테이블은 물리 메모리를 기준으로 프레임 테이블을 만들기 때문에 테이블 수가 1개일 수 밖에 없으며, 페이지 테이블의 행 수는 실제 프레임수와 같을 수 밖에 없다
- 테이블의 크기가 작지만 프로세스가 물리 메모리에 접근할 때 프로세스 아이디와 페이지 번호를 모두 찾아야 하는 것이 단점이다

## 세그먼테이션 기법

##### 세그먼테이션 기법의 구현
- 가변 분할 방식을 이용한 가상 메모리 관리 기법으로 물리 주소 공간을 프로세스 크기에 따라 가변적으로 나누어 사용한다
- 가상 메모리와 물리 메모리의 분할된 영역을 **세그먼트**라고 부른다. 각 세그먼트 영역은 번호를 매겨 관리한다
- 세그먼트 테이블은 2열로 구성되고 0번째 행부터 순서대로 세그먼트0으로 시작되며 1열은 세그먼트의 크기를 나타내는 limit, 2열은 물리메모리의 시작 주소인 address를 나타낸다. 물리 메모리에 올려져 있지 않는 가상 주소공간의 세그먼트는 테이블에 물리 주소가 아닌 'invalid'로 표기한다
- 세그먼테이션 기법은 메모리를 프로세스 단위로 관리하기 때문에 세그먼테이션 테이블이 작고 단순하다는 것이 장점이지만, 물리 메모리의 외부 단편화로 인해 관리가 복잡하다는 단점이 있다

##### 세그먼테이션 기법의 주소 변환
- 세그먼테이션 기법에서는 가상 주소를  VA = <S, D>로 표현한다(VA - virtual address, s - segmentnumber, D - 세그먼트 처음 위치에서 해당 주소까지 distance)
- 세그먼테이션 기법에서는 물리 주소는 세그먼테이션 테이블의 address + D(distance)이다
- 예시(세그먼트0을 차지하는 프로세스의 32번에 접근하려고 한다)
  1) VA = <0, 32>로 표현한다
  2) 세그먼트 테이블을 확인하여 세그먼트0의 물리메모리 시작 주소(address)를 알아내여 시작주소에서 D(distance)를 더한다
  3) 메모리관리자가 limit수치를 확인해 (address + D)의 값과 (address + limit)의 값을 비교하여 거리가 세그먼트의 크기보다 큰지 점검한다. 크다면 물리메모리를 벗어나는 것이므로 오류를 출력하고 프로세스를 강제종료한다
  4) address + D위치에 원하는 데이터를 읽거나 쓴다
